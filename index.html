<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Leśny Dwór Sulęczyno – Wedding Scene</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, sans-serif;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 13px;
      z-index: 10;
      border-radius: 4px;
    }
    a { color: #aad8ff; }
  </style>
</head>
<body>
<div id="info">
  Leśny Dwór – Sulęczyno, Poland<br/>
  Drag to orbit • Scroll to zoom • Right click to pan
</div>
<canvas id="c"></canvas>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<!-- Three.js and OrbitControls from CDN -->
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// Scene & camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xd4e4f4);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  2000
);
camera.position.set(10, 60, 250);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 20, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 50;
controls.maxDistance = 300;
controls.maxPolarAngle = Math.PI * 0.45;

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(50, 100, 200);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 50;
sun.shadow.camera.far = 800;
sun.shadow.camera.left = -250;
sun.shadow.camera.right = 250;
sun.shadow.camera.top = 250;
sun.shadow.camera.bottom = -250;
sun.shadow.bias = -0.001;
scene.add(sun);

const fill = new THREE.HemisphereLight(0xddeeff, 0x889988, 0.4);
scene.add(fill);

// Materials
const grassMat = new THREE.MeshStandardMaterial({
  color: 0x78946a,
  roughness: 0.85,
  metalness: 0.05
});

const pathMat = new THREE.MeshStandardMaterial({
  color: 0xced4da,
  roughness: 0.9
});

const gravelMat = new THREE.MeshStandardMaterial({
  color: 0xb0b4b8,
  roughness: 0.95
});

const waterMat = new THREE.MeshPhysicalMaterial({
  color: 0x5aa1b8,
  transparent: true,
  opacity: 0.9,
  roughness: 0.15,
  metalness: 0.45,
  clearcoat: 1.0,
  clearcoatRoughness: 0.1
});

waterMat.onBeforeCompile = (shader) => {
  shader.uniforms.uTime = { value: 0 };

  shader.vertexShader = `
    uniform float uTime;
    varying vec3 vWorldPosition;
    ${shader.vertexShader}
  `;

  shader.vertexShader = shader.vertexShader.replace(
    '#include <begin_vertex>',
    `
      #include <begin_vertex>

      float wave = sin((position.x + uTime * 10.0) * 0.02) * 0.4 +
                   cos((position.y - uTime * 6.0) * 0.018) * 0.3;
      transformed.z += wave;

      // Recalculate normals for correct lighting
      vec3 next_px = position;
      next_px.x += 0.1;
      float wave_px = sin((next_px.x + uTime * 10.0) * 0.02) * 0.4 +
                      cos((next_px.y - uTime * 6.0) * 0.018) * 0.3;
      next_px.z += wave_px;

      vec3 next_py = position;
      next_py.y += 0.1;
      float wave_py = sin((next_py.x + uTime * 10.0) * 0.02) * 0.4 +
                      cos((next_py.y - uTime * 6.0) * 0.018) * 0.3;
      next_py.z += wave_py;

      vec3 to_px = normalize(next_px - position);
      vec3 to_py = normalize(next_py - position);
      objectNormal = normalize(cross(to_py, to_px));

      vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
    `
  );

  waterMat.userData.shader = shader;
};

const façadeMat = new THREE.MeshStandardMaterial({
  color: 0xf8f4e9,
  roughness: 0.9
});

const accentStoneMat = new THREE.MeshStandardMaterial({
  color: 0xd1c8bd,
  roughness: 0.95
});

const roofMat = new THREE.MeshStandardMaterial({
  color: 0xcf6a47,
  roughness: 0.8
});

const darkRoofMat = new THREE.MeshStandardMaterial({
  color: 0x9d3a17,
  roughness: 0.55
});

const windowMat = new THREE.MeshStandardMaterial({
  color: 0x6c757d,
  transparent: true,
  opacity: 0.7,
  roughness: 0.1,
  metalness: 0.2
});

const solarMat = new THREE.MeshStandardMaterial({
  color: 0x1b2435,
  roughness: 0.15,
  metalness: 0.85
});

const treeTrunkMat = new THREE.MeshStandardMaterial({
  color: 0x5a3b26,
  roughness: 0.9
});

const treeLeafMat = new THREE.MeshStandardMaterial({
  color: 0x2e6b2f,
  roughness: 0.7
});

const hedgeMat = new THREE.MeshStandardMaterial({
  color: 0x31572b,
  roughness: 0.85
});

// Ground
function createGround() {
  // Main grass island plateau
  const groundGeo = new THREE.PlaneGeometry(600, 400);
  const ground = new THREE.Mesh(groundGeo, grassMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Light border to suggest shoreline transition
  const shoreGeo = new THREE.RingGeometry(210, 260, 64);
  const shoreMat = new THREE.MeshStandardMaterial({
    color: 0x8ca66c,
    side: THREE.DoubleSide,
    roughness: 0.9
  });
  const shore = new THREE.Mesh(shoreGeo, shoreMat);
  shore.rotation.x = -Math.PI / 2;
  shore.position.set(0, 0.05, -80);
  shore.receiveShadow = true;
  scene.add(shore);

}
createGround();

function createDriveway() {
  const shape = new THREE.Shape();
  shape.moveTo(-150, 120);
  shape.quadraticCurveTo(-100, 80, -50, 60);
  shape.quadraticCurveTo(0, 50, 50, 60);
  shape.quadraticCurveTo(100, 80, 150, 120);
  shape.lineTo(150, 100);
  shape.quadraticCurveTo(100, 60, 50, 40);
  shape.quadraticCurveTo(0, 30, -50, 40);
  shape.quadraticCurveTo(-100, 60, -150, 100);
  shape.lineTo(-150, 120);

  const extrudeSettings = { depth: 0.4, bevelEnabled: false };
  const drivewayGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  const driveway = new THREE.Mesh(drivewayGeo, pathMat);
  driveway.rotation.x = -Math.PI / 2;
  driveway.position.y = 0.1;
  driveway.receiveShadow = true;
  scene.add(driveway);

  const centerIsland = new THREE.Shape();
  centerIsland.moveTo(-40, 50);
  centerIsland.quadraticCurveTo(0, 40, 40, 50);
  centerIsland.quadraticCurveTo(0, 60, -40, 50);
  const islandGeo = new THREE.ShapeGeometry(centerIsland);
  const island = new THREE.Mesh(islandGeo, grassMat);
  island.rotation.x = -Math.PI / 2;
  island.position.y = 0.2;
  island.receiveShadow = true;
  scene.add(island);
}
createDriveway();

// Manor & buildings
function createRoof(width, depth, height, material) {
  const geo = new THREE.ConeGeometry(
    Math.max(width, depth) * 0.72,
    height,
    4,
    1
  );
  const mesh = new THREE.Mesh(geo, material);
  mesh.rotation.y = Math.PI / 4;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function addWindowsToFacade(group, width, height, rows, cols, zOffset) {
  const w = width / (cols + 1);
  const hSpacing = w;
  const vSpacing = height / (rows + 2);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const winGeo = new THREE.PlaneGeometry(w * 0.5, vSpacing * 0.7);
      const win = new THREE.Mesh(winGeo, windowMat);
      win.position.set(
        -width / 2 + (c + 1) * hSpacing,
        4 + (r + 1) * vSpacing,
        zOffset
      );
      win.castShadow = false;
      win.receiveShadow = false;
      group.add(win);

      // Simple white frame
      const frameGeo = new THREE.PlaneGeometry(w * 0.53, vSpacing * 0.75);
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0xe9ecef,
        roughness: 0.7
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.copy(win.position);
      frame.position.z += (zOffset > 0 ? 0.01 : -0.01);
      group.add(frame);
    }
  }
}

function createManor() {
  const manor = new THREE.Group();
  manor.position.set(0, 0, 40);

  // Central block (two stories)
  const centerWidth = 80;
  const centerDepth = 40;
  const centerHeight = 22;

  const centerGeo = new THREE.BoxGeometry(centerWidth, centerHeight, centerDepth);
  const center = new THREE.Mesh(centerGeo, façadeMat);
  center.position.y = centerHeight / 2;
  center.castShadow = true;
  center.receiveShadow = true;
  manor.add(center);

  // Stone base belt
  const baseGeo = new THREE.BoxGeometry(centerWidth, 3, centerDepth + 0.4);
  const base = new THREE.Mesh(baseGeo, accentStoneMat);
  base.position.y = 1.3;
  base.castShadow = true;
  base.receiveShadow = true;
  manor.add(base);

  // Central front risalit (the porch + balcony volume)
  const risWidth = 32;
  const risDepth = 8;
  const risHeight = 20;
  const risGeo = new THREE.BoxGeometry(risWidth, risHeight, risDepth);
  const ris = new THREE.Mesh(risGeo, façadeMat);
  ris.position.set(0, risHeight / 2 + 1, centerDepth / 2 + risDepth / 2 - 1);
  ris.castShadow = true;
  ris.receiveShadow = true;
  manor.add(ris);

  // Triangular front gable above risalit
  const gableShape = new THREE.Shape();
  gableShape.moveTo(-risWidth / 2, 0);
  gableShape.lineTo(risWidth / 2, 0);
  gableShape.lineTo(0, 14);
  gableShape.lineTo(-risWidth / 2, 0);
  const gableGeo = new THREE.ExtrudeGeometry(gableShape, {
    depth: 2,
    bevelEnabled: false
  });
  const gable = new THREE.Mesh(gableGeo, façadeMat);
  gable.rotation.y = Math.PI;
  gable.position.set(0, 19, centerDepth / 2 + risDepth - 1);
  gable.castShadow = true;
  gable.receiveShadow = true;
  manor.add(gable);

  // Central main roof
  const roof = createRoof(centerWidth + 10, centerDepth + 10, 18, roofMat);
  roof.position.set(0, centerHeight + 11, 0);
  manor.add(roof);

  // Risalit small roof
  const smallRoof = createRoof(risWidth + 4, risDepth + 6, 10, roofMat);
  smallRoof.position.set(0, 26, centerDepth / 2 + 8);
  manor.add(smallRoof);

  // Front colonnade (porch)
  const porchDepth = 8;
  const porchHeight = 9;
  const porchRoofGeo = new THREE.BoxGeometry(risWidth, 1.5, porchDepth);
  const porchRoof = new THREE.Mesh(porchRoofGeo, façadeMat);
  porchRoof.position.set(0, porchHeight + 1.5, centerDepth / 2 + risDepth / 2 + porchDepth / 2);
  porchRoof.castShadow = true;
  manor.add(porchRoof);

  const porchFloorGeo = new THREE.BoxGeometry(risWidth, 0.5, porchDepth);
  const porchFloor = new THREE.Mesh(porchFloorGeo, gravelMat);
  porchFloor.position.set(0, 0.25, centerDepth / 2 + risDepth / 2 + porchDepth / 2);
  porchFloor.receiveShadow = true;
  manor.add(porchFloor);

  const colGeo = new THREE.CylinderGeometry(1.2, 1.2, porchHeight, 16);
  const colMat = new THREE.MeshStandardMaterial({ color: 0xfdfbf5, roughness: 0.5 });
  const colPositions = [-risWidth / 2 + 6, risWidth / 2 - 6];
  colPositions.forEach(x => {
      const col = new THREE.Mesh(colGeo, colMat);
      col.position.set(x, porchHeight / 2 + 0.5, centerDepth / 2 + risDepth / 2 + porchDepth / 2);
      col.castShadow = true;
      manor.add(col);
  });

  const balconyRailGeo = new THREE.BoxGeometry(risWidth - 2, 1.5, 0.5);
  const balconyRail = new THREE.Mesh(balconyRailGeo, façadeMat);
  balconyRail.position.set(0, porchHeight + 2.5, centerDepth / 2 + risDepth / 2 + porchDepth);
  balconyRail.castShadow = true;
  manor.add(balconyRail);

  // Main entrance doorway
  const doorGeo = new THREE.BoxGeometry(8, 6, 0.5);
  const doorMat = new THREE.MeshStandardMaterial({ color: 0xded7cf, roughness: 0.7 });
  const door = new THREE.Mesh(doorGeo, doorMat);
  door.position.set(0, 4, centerDepth / 2 + risDepth + 0.26);
  door.castShadow = true;
  manor.add(door);

  // Entrance side windows (ground level)
  const sideWinGeo = new THREE.PlaneGeometry(4, 3);
  for (let i = -1; i <= 1; i += 2) {
    const sw = new THREE.Mesh(sideWinGeo, windowMat);
    sw.position.set(i * 9, 4.3, centerDepth / 2 + risDepth + 0.27);
    manor.add(sw);
  }

  // Windows on central block
  addWindowsToFacade(manor, centerWidth - 10, centerHeight - 6, 2, 4, centerDepth / 2 + 0.21);
  addWindowsToFacade(manor, centerWidth - 10, centerHeight - 6, 2, 4, -centerDepth / 2 - 0.21);

  // Left and right wings
  function createWing(sign) {
    const wing = new THREE.Group();

    const wingWidth = 80;
    const wingDepth = 26;
    const wingHeight = 16;

    const wingGeo = new THREE.BoxGeometry(wingWidth, wingHeight, wingDepth);
    const wingMesh = new THREE.Mesh(wingGeo, façadeMat);
    wingMesh.position.y = wingHeight / 2;
    wingMesh.castShadow = true;
    wingMesh.receiveShadow = true;
    wing.add(wingMesh);

    const wingBaseGeo = new THREE.BoxGeometry(wingWidth, 2.4, wingDepth + 0.3);
    const wingBase = new THREE.Mesh(wingBaseGeo, accentStoneMat);
    wingBase.position.y = 1.2;
    wingBase.castShadow = true;
    wingBase.receiveShadow = true;
    wing.add(wingBase);

    const wingRoof = createRoof(wingWidth + 4, wingDepth + 6, 14, roofMat);
    wingRoof.position.set(0, wingHeight + 7, 0);
    wing.add(wingRoof);

    // Wing windows (front & back)
    addWindowsToFacade(
      wing,
      wingWidth - 10,
      wingHeight - 4,
      1,
      5,
      wingDepth / 2 + 0.21
    );
    addWindowsToFacade(
      wing,
      wingWidth - 10,
      wingHeight - 4,
      1,
      5,
      -wingDepth / 2 - 0.21
    );

    // Slight inner bend toward courtyard
    wing.rotation.y = sign * (Math.PI / 24);
    wing.position.set(sign * (centerWidth / 2 + wingWidth / 2 - 4), 0, 0);

    return wing;
  }

  const leftWing = createWing(-1);
  const rightWing = createWing(1);
  manor.add(leftWing, rightWing);

  // Small terraces at ends (approximated)
  function createEndTerrace(sign) {
    const tGeo = new THREE.BoxGeometry(24, 1, 12);
    const t = new THREE.Mesh(tGeo, gravelMat);
    t.position.set(sign * (centerWidth / 2 + 70), 1, 14);
    t.castShadow = true;
    t.receiveShadow = true;
    manor.add(t);

    const railGeo2 = new THREE.BoxGeometry(22, 1, 1);
    const rail2 = new THREE.Mesh(railGeo2, façadeMat);
    rail2.position.set(sign * (centerWidth / 2 + 70), 3, 19);
    rail2.castShadow = true;
    manor.add(rail2);
  }
  createEndTerrace(-1);
  createEndTerrace(1);

  scene.add(manor);
}
createManor();

// Outbuilding with solar panels & parking
function createOutbuilding() {
  const group = new THREE.Group();
  group.position.set(-120, 0, 80);

  const bodyGeo = new THREE.BoxGeometry(60, 20, 28);
  const body = new THREE.Mesh(bodyGeo, façadeMat);
  body.position.y = 10;
  body.castShadow = true;
  body.receiveShadow = true;
  group.add(body);

  const roof = createRoof(60 + 4, 28 + 4, 16, darkRoofMat);
  roof.position.y = 30;
  group.add(roof);

  // Solar panels on roof
  const panelGeo = new THREE.BoxGeometry(14, 0.4, 6);
  for (let i = -1; i <= 1; i++) {
    const panel = new THREE.Mesh(panelGeo, solarMat);
    panel.rotation.x = -Math.PI / 10;
    panel.position.set(i * 18, 30.6, 10);
    panel.castShadow = true;
    group.add(panel);
  }

  // Ground solar arrays in front
  const frameGeo = new THREE.BoxGeometry(26, 1, 10);
  for (let i = 0; i < 3; i++) {
    const frame = new THREE.Mesh(frameGeo, solarMat);
    frame.position.set(-40 + i * 32, 2, 55);
    frame.rotation.x = -Math.PI / 7;
    frame.castShadow = true;
    group.add(frame);
  }

  // Parking area
  const parkGeo = new THREE.BoxGeometry(120, 0.4, 40);
  const park = new THREE.Mesh(parkGeo, pathMat);
  park.position.set(20, 0.4, 70);
  park.receiveShadow = true;
  group.add(park);

  // Simple parked cars as small boxes
  const carGeo = new THREE.BoxGeometry(7, 3, 4);
  const colors = [0x444bff, 0xf44336, 0x9e9e9e, 0x4caf50, 0x000000];
  for (let i = 0; i < 7; i++) {
    const mat = new THREE.MeshStandardMaterial({
      color: colors[i % colors.length],
      roughness: 0.5,
      metalness: 0.3
    });
    const car = new THREE.Mesh(carGeo, mat);
    car.position.set(-30 + i * 14, 1.8, 80 + (i % 2 === 0 ? -5 : 5));
    car.castShadow = true;
    car.receiveShadow = true;
    group.add(car);
  }

  scene.add(group);
}

// Trees, hedges, and lamp posts
function createRealisticTree(x, z, options = {}) {
  const {
    height = 20,
    crownRadius = 6,
    trunkRadius = 0.8,
    color = 0x446622,
  } = options;

  const group = new THREE.Group();
  group.position.set(x, 0, z);

  const trunkHeight = height * 0.4;
  const trunkGeo = new THREE.CylinderGeometry(
    trunkRadius * 0.7,
    trunkRadius,
    trunkHeight,
    12
  );
  const trunkMat = new THREE.MeshStandardMaterial({
    color: 0x624a2e,
    roughness: 0.9,
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = trunkHeight / 2;
  trunk.castShadow = true;
  group.add(trunk);

  const crownHeight = height * 0.6;
  const numSpheres = 8;
  const crownMat = new THREE.MeshStandardMaterial({
    color: color,
    roughness: 0.8,
  });

  for (let i = 0; i < numSpheres; i++) {
    const sphereRadius = crownRadius * (0.6 + Math.random() * 0.4);
    const sphereGeo = new THREE.SphereGeometry(sphereRadius, 8, 6);
    const sphere = new THREE.Mesh(sphereGeo, crownMat);

    sphere.position.set(
      (Math.random() - 0.5) * crownRadius * 0.8,
      trunkHeight + (Math.random() - 0.2) * crownHeight * 0.8,
      (Math.random() - 0.5) * crownRadius * 0.8
    );
    sphere.castShadow = true;
    group.add(sphere);
  }

  scene.add(group);
  return group;
}

function createHedgeLine(points, geometry) {
  const geo = geometry || new THREE.CylinderGeometry(1.3, 1.3, 3, 8);
  for (const p of points) {
    const h = new THREE.Mesh(geo, hedgeMat);
    h.position.set(p.x, 1.5, p.z);
    h.castShadow = true;
    h.receiveShadow = true;
    scene.add(h);
  }
}

function createLampPost(x, z) {
  const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
  const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.set(x, 2.5, z);
  pole.castShadow = true;
  pole.receiveShadow = true;

  const headGeo = new THREE.SphereGeometry(0.6, 8, 8);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xfff7d6, emissive: 0xfff3c4, emissiveIntensity: 0.7 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.set(x, 5.4, z);
  head.castShadow = true;

  scene.add(pole, head);
}

function populateLandscape() {
  createRealisticTree(-140, 0, { height: 35, crownRadius: 12, color: 0x3a592a });
  createRealisticTree(130, -20, { height: 32, crownRadius: 11, color: 0x41662f });
  createRealisticTree(-100, -80, { height: 38, crownRadius: 14, color: 0x334d22 });

  const hedgeGeo = new THREE.BoxGeometry(2.5, 3.5, 2.5);
  const points = [
      // Right side hedges from camera view
      { x: 80, z: 80 }, { x: 84, z: 80 }, { x: 88, z: 80 },
      { x: 92, z: 80 }, { x: 96, z: 80 }, { x: 100, z: 80 },
      // Left side hedges from camera view
      { x: -70, z: 90 }, { x: -74, z: 90 }, { x: -78, z: 90 },
      { x: -82, z: 90 }, { x: -86, z: 90 }, { x: -90, z: 90 },
  ];
  createHedgeLine(points, hedgeGeo);

  function createTopiary(x, z) {
      const baseGeo = new THREE.ConeGeometry(2, 4, 8);
      const base = new THREE.Mesh(baseGeo, hedgeMat);
      base.position.set(x, 2, z);
      base.castShadow = true;
      scene.add(base);
  }
  createTopiary(70, 70);
  createTopiary(-60, 80);
  createTopiary(110, 50);
}
populateLandscape();

// Bride and groom
function createPerson(options) {
  const group = new THREE.Group();
  const {
    height = 10,
    bodyColor = 0x000000,
    accentColor = 0xffffff,
    hairColor = 0x000000,
    isBride = false
  } = options;

  const scale = height / 10;

  // Torso
  const torsoGeo = new THREE.CylinderGeometry(
    isBride ? 1.6 * scale : 1.4 * scale,
    isBride ? 2.2 * scale : 1.6 * scale,
    4.5 * scale,
    16
  );
  const torsoMat = new THREE.MeshStandardMaterial({
    color: bodyColor,
    roughness: 0.6,
    metalness: 0.1
  });
  const torso = new THREE.Mesh(torsoGeo, torsoMat);
  torso.position.y = 4.5 * scale;
  torso.castShadow = true;
  torso.receiveShadow = true;
  group.add(torso);

  // Legs (only visible for groom)
  if (!isBride) {
    const legGeo = new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 4 * scale, 10);
    const legMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.7 });
    const leftLeg = new THREE.Mesh(legGeo, legMat);
    const rightLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.7 * scale, 2 * scale, 0);
    rightLeg.position.set(0.7 * scale, 2 * scale, 0);
    leftLeg.castShadow = rightLeg.castShadow = true;
    leftLeg.receiveShadow = rightLeg.receiveShadow = true;
    group.add(leftLeg, rightLeg);
  } else {
    // Wedding dress: long cone
    const dressGeo = new THREE.CylinderGeometry(0.7 * scale, 2.6 * scale, 5 * scale, 24);
    const dressMat = new THREE.MeshStandardMaterial({
      color: 0xfdfdfd,
      roughness: 0.7,
      metalness: 0.05
    });
    const dress = new THREE.Mesh(dressGeo, dressMat);
    dress.position.y = 3.1 * scale;
    dress.castShadow = true;
    dress.receiveShadow = true;
    group.add(dress);
  }

  // Neck
  const neckGeo = new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 0.8 * scale, 10);
  const skinMat = new THREE.MeshStandardMaterial({
    color: 0xffdab5,
    roughness: 0.6
  });
  const neck = new THREE.Mesh(neckGeo, skinMat);
  neck.position.y = 7 * scale;
  neck.castShadow = true;
  group.add(neck);

  // Head
  const headGeo = new THREE.SphereGeometry(1.3 * scale, 16, 16);
  const head = new THREE.Mesh(headGeo, skinMat);
  head.position.y = 8.7 * scale;
  head.castShadow = true;
  head.receiveShadow = true;
  group.add(head);

  // Hair
  const hairGeo = new THREE.SphereGeometry(1.35 * scale, 16, 16, 0, Math.PI * 2, 0, Math.PI);
  const hairMat = new THREE.MeshStandardMaterial({
    color: hairColor,
    roughness: 0.6
  });
  const hair = new THREE.Mesh(hairGeo, hairMat);
  hair.position.y = 9 * scale;
  hair.castShadow = true;
  group.add(hair);

  // Arms
  const armGeo = new THREE.CylinderGeometry(0.35 * scale, 0.35 * scale, 3.6 * scale, 10);
  const sleeveMat = new THREE.MeshStandardMaterial({
    color: bodyColor,
    roughness: 0.6
  });
  const leftArm = new THREE.Mesh(armGeo, sleeveMat);
  const rightArm = new THREE.Mesh(armGeo, sleeveMat);
  leftArm.position.set(-1.8 * scale, 5.8 * scale, 0.4 * scale);
  rightArm.position.set(1.8 * scale, 5.8 * scale, 0.4 * scale);
  leftArm.rotation.z = Math.PI / 10;
  rightArm.rotation.z = -Math.PI / 10;
  leftArm.castShadow = rightArm.castShadow = true;
  leftArm.receiveShadow = rightArm.receiveShadow = true;
  group.add(leftArm, rightArm);

  // Hands
  const handGeo = new THREE.SphereGeometry(0.45 * scale, 10, 10);
  const lHand = new THREE.Mesh(handGeo, skinMat);
  const rHand = new THREE.Mesh(handGeo, skinMat);
  lHand.position.copy(leftArm.position).add(new THREE.Vector3(0, -2.2 * scale, 0));
  rHand.position.copy(rightArm.position).add(new THREE.Vector3(0, -2.2 * scale, 0));
  lHand.castShadow = rHand.castShadow = true;
  group.add(lHand, rHand);

  // Details
  if (!isBride) {
    // Bow tie
    const bowGeo = new THREE.BoxGeometry(0.4 * scale, 0.2 * scale, 0.8 * scale);
    const bowMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.5 });
    const bow = new THREE.Mesh(bowGeo, bowMat);
    bow.position.set(0, 7.8 * scale, 1.3 * scale);
    bow.castShadow = true;
    group.add(bow);

    // Shirt stripe
    const stripeGeo = new THREE.BoxGeometry(0.4 * scale, 2.5 * scale, 0.1 * scale);
    const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
    const stripe = new THREE.Mesh(stripeGeo, stripeMat);
    stripe.position.set(0, 6.5 * scale, 1.35 * scale);
    group.add(stripe);
  } else {
    // Veil as transparent plane
    const veilGeo = new THREE.PlaneGeometry(4.5 * scale, 6 * scale);
    const veilMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.35,
      side: THREE.DoubleSide
    });
    const veil = new THREE.Mesh(veilGeo, veilMat);
    veil.position.set(0, 8.5 * scale, -1.1 * scale);
    veil.rotation.x = -0.3;
    veil.castShadow = false;
    group.add(veil);

    // Bouquet
    const bouquetGeo = new THREE.SphereGeometry(0.9 * scale, 10, 10);
    const bouquetMat = new THREE.MeshStandardMaterial({
      color: 0xff6f91,
      roughness: 0.7
    });
    const bouquet = new THREE.Mesh(bouquetGeo, bouquetMat);
    bouquet.position.set(0.5 * scale, 4.6 * scale, 1.6 * scale);
    bouquet.castShadow = true;
    group.add(bouquet);
  }

  return group;
}

function placeCouple() {
  const groom = createPerson({
    height: 11.5,
    bodyColor: 0x111111,
    accentColor: 0xb4001a,
    hairColor: 0x2d1b14,
    isBride: false
  });
  const bride = createPerson({
    height: 9.5,
    bodyColor: 0xffffff,
    accentColor: 0xffffff,
    hairColor: 0xf6d585,
    isBride: true
  });

  // Position them on the axis of the entrance, slightly in front of the fountain
  groom.position.set(35, 0, 28);
  bride.position.set(46, 0, 26);

  groom.rotation.y = Math.PI * 0.05;
  bride.rotation.y = -Math.PI * 0.05;

  scene.add(groom, bride);
}

// Animation loop (including small lake waves)
let clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Update water shader time uniform
  if (waterMat.userData.shader) {
    waterMat.userData.shader.uniforms.uTime.value = t;
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

// Resize handling
window.addEventListener('resize', () => {
  const { innerWidth, innerHeight } = window;
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
